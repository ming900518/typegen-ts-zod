use joinery::JoinableIterator;

use crate::rust_types::{RustType, RustTypeFormatError, SpecialRustType};
use crate::{
    language::{Language, SupportedLanguage},
    rust_types::{RustEnum, RustEnumVariant, RustField, RustStruct, RustTypeAlias},
};
use std::io;
use std::{collections::HashMap, io::Write};

/// All information needed to generate Typescript type-code
#[derive(Default)]
pub struct TypeScript {
    /// Mappings from Rust type names to Typescript type names
    pub type_mappings: HashMap<String, String>,
    /// Whether or not to exclude the version header that normally appears at the top of generated code.
    /// If you aren't generating a snapshot test, this setting can just be left as a default (false)
    pub no_version_header: bool,
}

impl Language for TypeScript {
    fn type_map(&mut self) -> &HashMap<String, String> {
        &self.type_mappings
    }

    fn format_special_type(
        &mut self,
        special_ty: &SpecialRustType,
        generic_types: &[String],
    ) -> Result<(String, bool), RustTypeFormatError> {
        match special_ty {
            SpecialRustType::Vec(rtype) | SpecialRustType::Slice(rtype) => {
                let formatted_type = self.format_type(rtype, generic_types)?;
                Ok((format!("{}[]", formatted_type.0), formatted_type.1))
            }
            SpecialRustType::Array(rtype, len) => {
                let formatted_type = self.format_type(rtype, generic_types)?;
                Ok((
                    format!(
                        "[{}]",
                        std::iter::repeat(&formatted_type.0)
                            .take(*len)
                            .join_with(", ")
                    ),
                    formatted_type.1,
                ))
            }
            // We add optionality above the type formatting level
            SpecialRustType::Option(rtype) => self.format_type(rtype, generic_types),
            SpecialRustType::HashMap(rtype1, rtype2) => Ok((
                format!(
                    "Record<{}, {}>",
                    match rtype1.as_ref() {
                        RustType::Simple { id } if generic_types.contains(id) => {
                            return Err(RustTypeFormatError::GenericKeyForbiddenInTS(id.clone()));
                        }
                        _ => self.format_type(rtype1, generic_types).map(|data| data.0)?,
                    },
                    self.format_type(rtype2, generic_types).map(|data| data.0)?
                ),
                true,
            )),
            SpecialRustType::Unit => Ok(("undefined".into(), false)),
            SpecialRustType::String | SpecialRustType::Char => Ok(("string".into(), false)),
            SpecialRustType::I8
            | SpecialRustType::U8
            | SpecialRustType::I16
            | SpecialRustType::U16
            | SpecialRustType::I32
            | SpecialRustType::U32
            | SpecialRustType::I54
            | SpecialRustType::U53
            | SpecialRustType::F32
            | SpecialRustType::F64 => Ok(("number".into(), false)),
            SpecialRustType::Bool => Ok(("boolean".into(), false)),
            SpecialRustType::U64
            | SpecialRustType::I64
            | SpecialRustType::ISize
            | SpecialRustType::USize => {
                panic!("64 bit types not allowed in Typeshare")
            }
        }
    }

    fn begin_file(&mut self, w: &mut dyn Write) -> io::Result<()> {
        if !self.no_version_header {
            writeln!(w, "/*")?;
            writeln!(
                w,
                " Generated by typeshare {} with additional Zod support by Ming Chang",
                env!("CARGO_PKG_VERSION")
            )?;
            writeln!(w, "*/")?;
            writeln!(w)?;
            writeln!(w, "import {{z}} from \"zod\";\n")?;
        }
        Ok(())
    }

    fn write_type_alias(&mut self, w: &mut dyn Write, ty: &RustTypeAlias) -> io::Result<()> {
        self.write_comments(w, 0, &ty.comments)?;

        let r#type = self
            .format_type(&ty.r#type, ty.generic_types.as_slice())
            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;

        writeln!(
            w,
            "export type {}{} = {}{};\n",
            ty.id.renamed,
            (!ty.generic_types.is_empty())
                .then(|| format!("<{}>", ty.generic_types.join(", ")))
                .unwrap_or_default(),
            r#type.0,
            ty.r#type
                .is_optional()
                .then(|| " | undefined")
                .unwrap_or_default(),
        )?;

        Ok(())
    }

    fn write_struct(&mut self, w: &mut dyn Write, rs: &RustStruct) -> io::Result<()> {
        self.write_comments(w, 0, &rs.comments)?;
        writeln!(
            w,
            "export class {}{} {{",
            rs.id.renamed,
            (!rs.generic_types.is_empty())
                .then(|| format!("<{}>", rs.generic_types.join(", ")))
                .unwrap_or_default()
        )?;

        rs.fields
            .iter()
            .try_for_each(|f| self.write_class_field(w, f, rs.generic_types.as_slice()))?;

        writeln!(
            w,
            r#"
    constructor(data: z.infer<typeof {}.schema>) {{
        Object.assign(this, {}.schema.parse(data));
    }}
"#,
            rs.id.renamed, rs.id.renamed
        )?;

        writeln!(w, "\tstatic schema = z.object({{")?;

        rs.fields
            .iter()
            .try_for_each(|f| self.write_class_zod_field(w, f, rs.generic_types.as_slice()))?;

        writeln!(w, "\t}});\n}}\n")
    }

    fn write_enum(&mut self, w: &mut dyn Write, e: &RustEnum) -> io::Result<()> {
        self.write_comments(w, 0, &e.shared().comments)?;

        let generic_parameters = (!e.shared().generic_types.is_empty())
            .then(|| format!("<{}>", e.shared().generic_types.join(", ")))
            .unwrap_or_default();

        match e {
            RustEnum::Unit(shared) => {
                write!(
                    w,
                    "export enum {}{} {{",
                    shared.id.renamed, generic_parameters
                )?;

                self.write_enum_variants(w, e)?;

                writeln!(w, "\n}}\n")?;

                let mut name_chars = shared.id.renamed.chars().collect::<Vec<char>>();

                writeln!(
                    w,
                    "const {}{} = z.nativeEnum({});\n",
                    name_chars.remove(0).to_lowercase(),
                    name_chars.iter().collect::<String>(),
                    shared.id.renamed
                )
            }
            RustEnum::Algebraic { shared, .. } => {
                write!(
                    w,
                    "export type {}{} = ",
                    shared.id.renamed, generic_parameters
                )?;

                self.write_enum_variants(w, e)?;

                write!(w, ";")?;
                writeln!(w)?;
                writeln!(w)?;

                let mut name_chars = shared.id.renamed.chars().collect::<Vec<char>>();

                write!(
                    w,
                    "const {}{} = z.union([",
                    name_chars.remove(0).to_lowercase(),
                    name_chars.iter().collect::<String>(),
                )?;
                self.write_enum_variants_zod(w, e)?;
                writeln!(w, "]);\n")
            }
        }
    }
}

impl TypeScript {
    fn write_enum_variants(&mut self, w: &mut dyn Write, e: &RustEnum) -> io::Result<()> {
        match e {
            // Write all the unit variants out (there can only be unit variants in
            // this case)
            RustEnum::Unit(shared) => shared.variants.iter().try_for_each(|v| match v {
                RustEnumVariant::Unit(shared) => {
                    writeln!(w)?;
                    self.write_comments(w, 1, &shared.comments)?;
                    write!(w, "\t{} = {:?},", shared.id.original, &shared.id.renamed)
                }
                _ => unreachable!(),
            }),

            // Write all the algebraic variants out (all three variant types are possible
            // here)
            RustEnum::Algebraic {
                tag_key,
                content_key,
                shared,
            } => shared.variants.iter().try_for_each(|v| {
                writeln!(w)?;
                self.write_comments(w, 1, &v.shared().comments)?;
                match v {
                    RustEnumVariant::Unit(shared) => {
                        write!(w, "\t| {{ {}: {:?} }}", tag_key, shared.id.renamed)
                    }
                    RustEnumVariant::Tuple { ty, shared } => {
                        let r#type = self
                            .format_type(ty, e.shared().generic_types.as_slice())
                            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
                        write!(
                            w,
                            "\t| {{ {}: {:?}, {}{}: {} }}",
                            tag_key,
                            shared.id.renamed,
                            content_key,
                            ty.is_optional().then(|| "?").unwrap_or_default(),
                            r#type.0
                        )
                    }
                    RustEnumVariant::AnonymousStruct { fields, shared } => {
                        writeln!(
                            w,
                            "\t| {{ {}: {:?}, {}: {{",
                            tag_key, shared.id.renamed, content_key
                        )?;

                        fields.iter().try_for_each(|f| {
                            self.write_enum_field(w, f, e.shared().generic_types.as_slice())
                        })?;

                        write!(w, "}}")?;
                        write!(w, "}}")
                    }
                }
            }),
        }
    }

    fn write_enum_field(
        &mut self,
        w: &mut dyn Write,
        field: &RustField,
        generic_types: &[String],
    ) -> io::Result<()> {
        self.write_comments(w, 1, &field.comments)?;
        let ts_ty: (String, bool) = match field.type_override(SupportedLanguage::TypeScript) {
            Some(type_override) => (type_override.to_owned(), false),
            None => self
                .format_type(&field.ty, generic_types)
                .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,
        };

        let optional = field.ty.is_optional() || field.has_default;
        let double_optional = field.ty.is_double_optional();
        let is_readonly = field
            .decorators
            .get(&SupportedLanguage::TypeScript)
            .filter(|v| v.iter().any(|dec| dec.name() == "readonly"))
            .is_some();
        writeln!(
            w,
            "\t{}{}{}: {}{};",
            is_readonly.then(|| "readonly ").unwrap_or_default(),
            typescript_property_aware_rename(&field.id.renamed),
            optional.then(|| "?").unwrap_or_default(),
            ts_ty.0,
            double_optional.then(|| " | null").unwrap_or_default()
        )?;

        Ok(())
    }

    fn write_enum_variants_zod(&mut self, w: &mut dyn Write, e: &RustEnum) -> io::Result<()> {
        match e {
            // Write all the unit variants out (there can only be unit variants in
            // this case)
            RustEnum::Unit(shared) => shared.variants.iter().try_for_each(|v| match v {
                RustEnumVariant::Unit(shared) => {
                    writeln!(w)?;
                    self.write_comments(w, 1, &shared.comments)?;
                    write!(w, "\t{}: z.{:?}(),", shared.id.original, &shared.id.renamed)
                }
                _ => unreachable!(),
            }),

            // Write all the algebraic variants out (all three variant types are possible
            // here)
            RustEnum::Algebraic {
                tag_key,
                content_key,
                shared,
            } => shared.variants.iter().try_for_each(|v| {
                writeln!(w)?;
                self.write_comments(w, 1, &v.shared().comments)?;
                match v {
                    RustEnumVariant::Unit(shared) => {
                        write!(
                            w,
                            "\tz.object({{{}: z.literal({:?})}}),",
                            tag_key, shared.id.renamed
                        )
                    }
                    RustEnumVariant::Tuple { ty, shared } => {
                        let r#type = self
                            .format_type(ty, e.shared().generic_types.as_slice())
                            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
                        write!(
                            w,
                            "\tz.object({{\n\t\t{}: z.literal({:?}),\n\t\t{}: z.{}(){}\n\t}}),",
                            tag_key,
                            shared.id.renamed,
                            content_key,
                            r#type.0,
                            ty.is_optional().then(|| ".nullable()").unwrap_or_default(),
                        )
                    }
                    RustEnumVariant::AnonymousStruct { fields, shared } => {
                        writeln!(
                            w,
                            "\tz.object({{\n\t\t{}: z.literal({:?}),\n\t\t{}: z.object({{",
                            tag_key, shared.id.renamed, content_key
                        )?;

                        fields.iter().try_for_each(|f| {
                            self.write_enum_field_zod(w, f, e.shared().generic_types.as_slice())
                        })?;

                        write!(w, "}})")?;
                        write!(w, "}})")
                    }
                }
            }),
        }
    }

    fn write_enum_field_zod(
        &mut self,
        w: &mut dyn Write,
        field: &RustField,
        generic_types: &[String],
    ) -> io::Result<()> {
        self.write_comments(w, 1, &field.comments)?;
        let ts_ty: (String, bool) = match field.type_override(SupportedLanguage::TypeScript) {
            Some(type_override) => (type_override.to_owned(), false),
            None => self
                .format_type(&field.ty, generic_types)
                .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,
        };

        let optional = field.ty.is_optional() || field.has_default;
        let double_optional = field.ty.is_double_optional();
        let is_readonly = field
            .decorators
            .get(&SupportedLanguage::TypeScript)
            .filter(|v| v.iter().any(|dec| dec.name() == "readonly"))
            .is_some();
        writeln!(
            w,
            "\t\t{}: z.{}(){}{}{},",
            typescript_property_aware_rename(&field.id.renamed),
            ts_ty.0,
            optional.then(|| ".nullable()").unwrap_or_default(),
            double_optional.then(|| ".optional()").unwrap_or_default(),
            is_readonly.then(|| ".readonly()").unwrap_or_default(),
        )?;

        Ok(())
    }

    fn write_class_field(
        &mut self,
        w: &mut dyn Write,
        field: &RustField,
        generic_types: &[String],
    ) -> io::Result<()> {
        self.write_comments(w, 1, &field.comments)?;
        let ts_ty: (String, bool) = match field.type_override(SupportedLanguage::TypeScript) {
            Some(type_override) => (type_override.to_owned(), false),
            None => self
                .format_type(&field.ty, generic_types)
                .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,
        };

        let optional = field.ty.is_optional() || field.has_default;
        let double_optional = field.ty.is_double_optional();
        let is_readonly = field
            .decorators
            .get(&SupportedLanguage::TypeScript)
            .filter(|v| v.iter().any(|dec| dec.name() == "readonly"))
            .is_some();
        writeln!(
            w,
            "\t{}{}{}: {}{};",
            is_readonly.then(|| "readonly ").unwrap_or_default(),
            typescript_property_aware_rename(&field.id.renamed),
            match double_optional {
                true => "?",
                false => "!",
            },
            ts_ty.0,
            optional.then(|| " | null").unwrap_or_default()
        )?;

        Ok(())
    }

    fn write_class_zod_field(
        &mut self,
        w: &mut dyn Write,
        field: &RustField,
        generic_types: &[String],
    ) -> io::Result<()> {
        self.write_comments(w, 1, &field.comments)?;
        let ts_ty: (String, bool) = match field.type_override(SupportedLanguage::TypeScript) {
            Some(type_override) => (type_override.to_owned(), false),
            None => self
                .format_type(&field.ty, generic_types)
                .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,
        };

        let optional = field.ty.is_optional() || field.has_default;
        let double_optional = field.ty.is_double_optional();
        let is_readonly = field
            .decorators
            .get(&SupportedLanguage::TypeScript)
            .filter(|v| v.iter().any(|dec| dec.name() == "readonly"))
            .is_some();
        writeln!(
            w,
            "\t\t{}: {}{}{}{},",
            typescript_property_aware_rename(&field.id.renamed),
            if ts_ty.0.contains("[]") {
                format!(
                    "z.array({}{}())",
                    if !ts_ty.1 { "z." } else { "" },
                    ts_ty.0.strip_suffix("[]").unwrap_or_default(),
                )
            } else {
                format!(
                    "{}{}{}",
                    if !ts_ty.1 { "z." } else { "" },
                    {
                        if !ts_ty.1 {
                            ts_ty.0
                        } else {
                            let mut ty_char = ts_ty.0.chars().collect::<Vec<char>>();
                            format!(
                                "{}{}",
                                ty_char.remove(0).to_lowercase(),
                                ty_char.iter().collect::<String>()
                            )
                        }
                    },
                    if !ts_ty.1 { "()" } else { "" }
                )
            },
            optional.then(|| ".nullable()").unwrap_or_default(),
            double_optional.then(|| ".optional()").unwrap_or_default(),
            is_readonly.then(|| ".readonly()").unwrap_or_default()
        )?;
        Ok(())
    }

    fn write_comments(
        &mut self,
        w: &mut dyn Write,
        indent: usize,
        comments: &[String],
    ) -> io::Result<()> {
        // Only attempt to write a comment if there are some, otherwise we're Ok()
        if !comments.is_empty() {
            let comment: String = {
                let tab_indent = "\t".repeat(indent);
                // If there's only one comment then keep it on the same line, otherwise we'll make a nice multi-line comment
                if comments.len() == 1 {
                    format!("{}/** {} */", tab_indent, comments.first().unwrap())
                } else {
                    let joined_comments = comments.join(&format!("\n{} * ", tab_indent));
                    format!(
                        "{tab}/**
{tab} * {comment}
{tab} */",
                        tab = tab_indent,
                        comment = joined_comments
                    )
                }
            };
            writeln!(w, "{}", comment)?;
        }
        Ok(())
    }
}

fn typescript_property_aware_rename(name: &str) -> String {
    if name.chars().any(|c| c == '-') {
        return format!("{:?}", name);
    }
    name.to_string()
}
